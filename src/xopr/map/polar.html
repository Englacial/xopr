<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Polar Map Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/ol@10.2.1/dist/ol.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@10.2.1/ol.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.11.0/proj4.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #map { 
            width: 100%; 
            height: 600px;
        }
        .map-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="map-info" id="info">Click on features for details</div>
    
    <script type="module">
        import init, { readParquet } from './parquet_wasm.js';
        import * as arrow from 'https://cdn.jsdelivr.net/npm/apache-arrow@14.0.2/+esm';
        
        // Configuration - these will be replaced by Myst
        const CONFIG = {
            pole: 'south',  // 'north' or 'south'
            parquetFiles: ['test_antarctic_random_walk.parquet'],  // list of parquet files
            centerLon: 0,  // center longitude for north pole projection
            defaultZoom: 3
        };
        
        // Setup projections
        const PROJECTIONS = {
            south: {
                code: 'EPSG:3031',
                def: '+proj=stere +lat_0=-90 +lat_ts=-71 +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +type=crs',
                extent: [-3369955, -3369955, 3369955, 3369955],
                wmsUrl: 'https://gibs.earthdata.nasa.gov/wms/epsg3031/best/wms.cgi',
                wmsLayer: 'BlueMarble_ShadedRelief'
            },
            north: {
                code: 'EPSG:3413',
                def: '+proj=stere +lat_0=90 +lat_ts=70 +lon_0=-45 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +type=crs',
                extent: [-4194304, -4194304, 4194304, 4194304],
                wmsUrl: 'https://gibs.earthdata.nasa.gov/wms/epsg3413/best/wms.cgi',
                wmsLayer: 'BlueMarble_ShadedRelief'
            }
        };
        
        const projConfig = PROJECTIONS[CONFIG.pole];
        
        // Define projection
        proj4.defs(projConfig.code, projConfig.def);
        ol.proj.proj4.register(proj4);
        
        const projection = ol.proj.get(projConfig.code);
        projection.setExtent(projConfig.extent);
        
        // Create map
        const map = new ol.Map({
            target: 'map',
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.TileWMS({
                        url: projConfig.wmsUrl,
                        params: {
                            'LAYERS': projConfig.wmsLayer,
                            'FORMAT': 'image/jpeg',
                            'SRS': projConfig.code
                        },
                        projection: projection,
                        crossOrigin: 'anonymous'
                    })
                })
            ],
            view: new ol.View({
                projection: projection,
                center: [0, 0],
                zoom: CONFIG.defaultZoom
            })
        });
        
        // WKB parser
        function parseWKB(wkbData) {
            try {
                let buffer;
                if (wkbData instanceof Uint8Array) {
                    buffer = wkbData.buffer.slice(wkbData.byteOffset, wkbData.byteOffset + wkbData.byteLength);
                } else if (wkbData instanceof ArrayBuffer) {
                    buffer = wkbData;
                } else if (wkbData && wkbData.toArray) {
                    const arr = wkbData.toArray();
                    buffer = new Uint8Array(arr).buffer;
                } else {
                    return null;
                }
                
                const view = new DataView(buffer);
                let offset = 0;
                const littleEndian = view.getUint8(offset) === 1;
                offset += 1;
                
                const geomType = view.getUint32(offset, littleEndian);
                offset += 4;
                
                if (geomType === 1) { // Point
                    const x = view.getFloat64(offset, littleEndian);
                    offset += 8;
                    const y = view.getFloat64(offset, littleEndian);
                    return { type: 'Point', coordinates: [x, y] };
                    
                } else if (geomType === 2) { // LineString
                    const numPoints = view.getUint32(offset, littleEndian);
                    offset += 4;
                    const coordinates = [];
                    for (let i = 0; i < numPoints; i++) {
                        const x = view.getFloat64(offset, littleEndian);
                        offset += 8;
                        const y = view.getFloat64(offset, littleEndian);
                        offset += 8;
                        coordinates.push([x, y]);
                    }
                    return { type: 'LineString', coordinates };
                    
                } else if (geomType === 3) { // Polygon
                    const numRings = view.getUint32(offset, littleEndian);
                    offset += 4;
                    const rings = [];
                    for (let r = 0; r < numRings; r++) {
                        const numPoints = view.getUint32(offset, littleEndian);
                        offset += 4;
                        const ring = [];
                        for (let i = 0; i < numPoints; i++) {
                            const x = view.getFloat64(offset, littleEndian);
                            offset += 8;
                            const y = view.getFloat64(offset, littleEndian);
                            offset += 8;
                            ring.push([x, y]);
                        }
                        rings.push(ring);
                    }
                    return { type: 'Polygon', coordinates: rings };
                }
                return null;
            } catch (e) {
                console.error('WKB parse error:', e);
                return null;
            }
        }
        
        // Load parquet file
        async function loadParquetFile(filename) {
            const response = await fetch(filename);
            const arrayBuffer = await response.arrayBuffer();
            const wasmTable = readParquet(new Uint8Array(arrayBuffer));
            const ipcStream = wasmTable.intoIPCStream();
            const arrowTable = arrow.tableFromIPC(ipcStream);
            
            const features = [];
            const geometryColumn = arrowTable.getChild('geometry');
            const nameColumn = arrowTable.getChild('name');
            const descriptionColumn = arrowTable.getChild('description');
            
            for (let i = 0; i < arrowTable.numRows; i++) {
                const wkbData = geometryColumn?.get(i);
                if (wkbData) {
                    const geom = parseWKB(wkbData);
                    if (geom) {
                        let olGeometry;
                        
                        if (geom.type === 'Point') {
                            const coords = ol.proj.transform(geom.coordinates, 'EPSG:4326', projConfig.code);
                            olGeometry = new ol.geom.Point(coords);
                        } else if (geom.type === 'LineString') {
                            const coords = geom.coordinates.map(c => 
                                ol.proj.transform(c, 'EPSG:4326', projConfig.code)
                            );
                            olGeometry = new ol.geom.LineString(coords);
                        } else if (geom.type === 'Polygon') {
                            const rings = geom.coordinates.map(ring =>
                                ring.map(c => ol.proj.transform(c, 'EPSG:4326', projConfig.code))
                            );
                            olGeometry = new ol.geom.Polygon(rings);
                        }
                        
                        if (olGeometry) {
                            features.push(new ol.Feature({
                                geometry: olGeometry,
                                name: nameColumn?.get(i) || `Feature ${i}`,
                                description: descriptionColumn?.get(i) || '',
                                source_file: filename
                            }));
                        }
                    }
                }
            }
            
            return features;
        }
        
        // Initialize and load all parquet files
        async function initialize() {
            try {
                await init('./parquet_wasm_bg.wasm');
                
                const allFeatures = [];
                for (const file of CONFIG.parquetFiles) {
                    try {
                        const features = await loadParquetFile(file);
                        allFeatures.push(...features);
                    } catch (e) {
                        console.error(`Error loading ${file}:`, e);
                    }
                }
                
                if (allFeatures.length > 0) {
                    const vectorSource = new ol.source.Vector({ features: allFeatures });
                    
                    // Style function for different geometry types
                    const styleFunction = function(feature) {
                        const geomType = feature.getGeometry().getType();
                        
                        const styles = {
                            'Point': new ol.style.Style({
                                image: new ol.style.Circle({
                                    radius: 6,
                                    fill: new ol.style.Fill({ color: 'rgba(255, 0, 0, 0.8)' }),
                                    stroke: new ol.style.Stroke({ color: '#fff', width: 1.5 })
                                })
                            }),
                            'LineString': new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: '#ff0000',
                                    width: 2
                                })
                            }),
                            'Polygon': new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: '#ff0000',
                                    width: 2
                                }),
                                fill: new ol.style.Fill({
                                    color: 'rgba(255, 0, 0, 0.1)'
                                })
                            })
                        };
                        
                        return styles[geomType] || styles['Point'];
                    };
                    
                    const vectorLayer = new ol.layer.Vector({
                        source: vectorSource,
                        style: styleFunction
                    });
                    
                    map.addLayer(vectorLayer);
                    
                    // Fit to extent
                    const extent = vectorSource.getExtent();
                    if (!ol.extent.isEmpty(extent)) {
                        map.getView().fit(extent, {
                            padding: [50, 50, 50, 50],
                            duration: 1000
                        });
                    }
                }
                
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('info').innerHTML = 'Error loading data';
            }
        }
        
        // Feature click handler
        map.on('click', function(evt) {
            const feature = map.forEachFeatureAtPixel(evt.pixel, f => f);
            if (feature) {
                const props = feature.getProperties();
                document.getElementById('info').innerHTML = 
                    `<strong>${props.name}</strong>${props.description ? '<br>' + props.description : ''}`;
            } else {
                const coords = evt.coordinate;
                const lonlat = ol.proj.transform(coords, projConfig.code, 'EPSG:4326');
                document.getElementById('info').innerHTML = 
                    `${lonlat[1].toFixed(4)}°, ${lonlat[0].toFixed(4)}°`;
            }
        });
        
        // Hover cursor change
        map.on('pointermove', function(evt) {
            const pixel = map.getEventPixel(evt.originalEvent);
            const hit = map.hasFeatureAtPixel(pixel);
            map.getTarget().style.cursor = hit ? 'pointer' : '';
        });
        
        // Start
        initialize();
    </script>
</body>
</html>