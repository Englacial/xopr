<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Polar Map Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/ol@10.2.1/dist/ol.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@10.2.1/ol.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.11.0/proj4.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #map { 
            width: 100%; 
            height: 600px;
        }
        .map-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 1000;
        }
        .cors-status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 11px;
            z-index: 1000;
            display: none;
        }
        .cors-status.visible { display: block; }
        .cors-status.success { border-left: 3px solid #28a745; }
        .cors-status.proxy { border-left: 3px solid #ffc107; }
        .cors-status.error { border-left: 3px solid #dc3545; }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="map-info" id="info">Click on features for details</div>
    <div class="cors-status" id="corsStatus"></div>
    
    <script type="module">
        // Load WASM modules from Google Cloud Storage to avoid path resolution issues
        // Local files are at: src/xopr/map/parquet_wasm.js and src/xopr/map/parquet_wasm_bg.wasm
        console.log('Loading WASM module from GCS');
        const { default: init, readParquet } = await import('https://storage.googleapis.com/opr_test_dataset_1/parquet_wasm.js');
        import * as arrow from 'https://cdn.jsdelivr.net/npm/apache-arrow@14.0.2/+esm';
        
        // Make CONFIG settable even before the script runs
        if (typeof window.CONFIG === 'undefined') {
            window.CONFIG = null;
        }
        
        // Allow parent to set CONFIG even after initialization
        let configUsed = false;
        
        // Wait for CONFIG to be set by parent window (NO DEFAULTS)
        function getConfig() {
            // Check if CONFIG was set by parent window
            if (window.CONFIG && typeof window.CONFIG === 'object') {
                console.log('Using parent-provided CONFIG:', window.CONFIG);
                configUsed = true;
                return window.CONFIG;
            }
            // No defaults - CONFIG must be explicitly provided
            console.error('ERROR: No CONFIG provided. Map requires configuration.');
            document.getElementById('map').innerHTML = 
                '<div style="padding: 20px; text-align: center; color: #721c24; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; margin: 20px;">' +
                '<strong>Configuration Required</strong><br>' +
                'CONFIG must be provided with pole and parquetFiles.<br>' +
                '<code style="font-size: 11px;">Example: {pole: "south", parquetFiles: [...], defaultZoom: 3}</code>' +
                '</div>';
            return null;
        }
        
        // Delay initialization to allow parent to set CONFIG
        async function waitForConfig() {
            // Give parent window more time to set CONFIG
            // Try multiple times to check for CONFIG
            for (let i = 0; i < 10; i++) {
                if (window.CONFIG && typeof window.CONFIG === 'object') {
                    console.log(`CONFIG found after ${i * 50}ms`);
                    break;
                }
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            
            // Final wait for document ready
            await new Promise(resolve => {
                if (document.readyState !== 'complete') {
                    window.addEventListener('load', resolve);
                } else {
                    setTimeout(resolve, 50);
                }
            });
            
            return getConfig();
        }
        
        // Setup projections
        const PROJECTIONS = {
            south: {
                code: 'EPSG:3031',
                def: '+proj=stere +lat_0=-90 +lat_ts=-71 +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +type=crs',
                extent: [-3369955, -3369955, 3369955, 3369955],
                wmsUrl: 'https://gibs.earthdata.nasa.gov/wms/epsg3031/best/wms.cgi',
                wmsLayer: 'BlueMarble_ShadedRelief'
            },
            north: {
                code: 'EPSG:3413',
                def: '+proj=stere +lat_0=90 +lat_ts=70 +lon_0=-45 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +type=crs',
                extent: [-4194304, -4194304, 4194304, 4194304],
                wmsUrl: 'https://gibs.earthdata.nasa.gov/wms/epsg3413/best/wms.cgi',
                wmsLayer: 'BlueMarble_ShadedRelief'
            }
        };
        
        // Initialize map and features after CONFIG is ready
        async function initializeMap() {
            const CONFIG = await waitForConfig();
            if (!CONFIG) {
                // CONFIG is required - error already displayed
                return null;
            }
            const projConfig = PROJECTIONS[CONFIG.pole];
            
            // Define projection
            proj4.defs(projConfig.code, projConfig.def);
            ol.proj.proj4.register(proj4);
            
            const projection = ol.proj.get(projConfig.code);
            projection.setExtent(projConfig.extent);
            
            // Create map
            const map = new ol.Map({
                target: 'map',
                layers: [
                    new ol.layer.Tile({
                        source: new ol.source.TileWMS({
                            url: projConfig.wmsUrl,
                            params: {
                                'LAYERS': projConfig.wmsLayer,
                                'FORMAT': 'image/jpeg',
                                'SRS': projConfig.code
                            },
                            projection: projection,
                            crossOrigin: 'anonymous'
                        })
                    })
                ],
                view: new ol.View({
                    projection: projection,
                    center: [0, 0],
                    zoom: CONFIG.defaultZoom
                })
            });
            
            return { map, projConfig, CONFIG };
        }
        
        // WKB parser
        function parseWKB(wkbData) {
            try {
                let buffer;
                if (wkbData instanceof Uint8Array) {
                    buffer = wkbData.buffer.slice(wkbData.byteOffset, wkbData.byteOffset + wkbData.byteLength);
                } else if (wkbData instanceof ArrayBuffer) {
                    buffer = wkbData;
                } else if (wkbData && wkbData.toArray) {
                    const arr = wkbData.toArray();
                    buffer = new Uint8Array(arr).buffer;
                } else {
                    return null;
                }
                
                const view = new DataView(buffer);
                let offset = 0;
                const littleEndian = view.getUint8(offset) === 1;
                offset += 1;
                
                const geomType = view.getUint32(offset, littleEndian);
                offset += 4;
                
                if (geomType === 1) { // Point
                    const x = view.getFloat64(offset, littleEndian);
                    offset += 8;
                    const y = view.getFloat64(offset, littleEndian);
                    return { type: 'Point', coordinates: [x, y] };
                    
                } else if (geomType === 2) { // LineString
                    const numPoints = view.getUint32(offset, littleEndian);
                    offset += 4;
                    const coordinates = [];
                    for (let i = 0; i < numPoints; i++) {
                        const x = view.getFloat64(offset, littleEndian);
                        offset += 8;
                        const y = view.getFloat64(offset, littleEndian);
                        offset += 8;
                        coordinates.push([x, y]);
                    }
                    return { type: 'LineString', coordinates };
                    
                } else if (geomType === 3) { // Polygon
                    const numRings = view.getUint32(offset, littleEndian);
                    offset += 4;
                    const rings = [];
                    for (let r = 0; r < numRings; r++) {
                        const numPoints = view.getUint32(offset, littleEndian);
                        offset += 4;
                        const ring = [];
                        for (let i = 0; i < numPoints; i++) {
                            const x = view.getFloat64(offset, littleEndian);
                            offset += 8;
                            const y = view.getFloat64(offset, littleEndian);
                            offset += 8;
                            ring.push([x, y]);
                        }
                        rings.push(ring);
                    }
                    return { type: 'Polygon', coordinates: rings };
                }
                return null;
            } catch (e) {
                console.error('WKB parse error:', e);
                return null;
            }
        }
        
        // Smart fetch with automatic CORS proxy fallback
        async function smartFetch(url, options = {}) {
            const statusEl = document.getElementById('corsStatus');
            
            // First, try direct fetch
            try {
                console.log('Attempting direct fetch:', url);
                const response = await fetch(url, {
                    ...options,
                    mode: 'cors',
                    credentials: 'omit'
                });
                
                if (response.ok) {
                    console.log('Direct fetch successful');
                    if (statusEl) {
                        statusEl.className = 'cors-status visible success';
                        statusEl.textContent = '✓ Direct';
                    }
                    return response;
                }
            } catch (error) {
                console.log('Direct fetch failed, trying proxy...', error.message);
            }
            
            // If direct fetch fails, try proxy
            try {
                const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
                console.log('Trying proxy:', proxyUrl);
                
                const response = await fetch(proxyUrl, options);
                
                if (response.ok) {
                    console.log('Proxy successful');
                    if (statusEl) {
                        statusEl.className = 'cors-status visible proxy';
                        statusEl.textContent = '⚡ Proxy';
                    }
                    return response;
                }
            } catch (error) {
                console.log('Proxy failed:', error.message);
            }
            
            // All attempts failed
            if (statusEl) {
                statusEl.className = 'cors-status visible error';
                statusEl.textContent = '✗ Failed';
            }
            throw new Error('Failed to fetch resource');
        }
        
        // Store collection geometries by filename
        const collectionGeometries = {};
        
        // Load parquet file with smart CORS handling
        async function loadParquetFile(filename, projConfig) {
            console.log(`Loading parquet file: ${filename}`);
            
            try {
                // For remote files, use smartFetch with fallback
                let response;
                if (filename.startsWith('http://') || filename.startsWith('https://')) {
                    response = await smartFetch(filename);
                } else {
                    // For local files, use regular fetch
                    response = await fetch(filename);
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${filename}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                console.log(`Successfully fetched ${filename}, size: ${arrayBuffer.byteLength} bytes`);
                const wasmTable = readParquet(new Uint8Array(arrayBuffer));
                
                // Try to extract collection geometry from metadata
                try {
                    const metadata = wasmTable.metadata();
                    if (metadata) {
                        const metadataObj = JSON.parse(metadata);
                        if (metadataObj['stac-geoparquet'] && metadataObj['stac-geoparquet'].collection) {
                            const collection = metadataObj['stac-geoparquet'].collection;
                            if (collection['proj:geometry']) {
                                console.log('Found proj:geometry for', filename);
                                collectionGeometries[filename] = collection['proj:geometry'];
                            }
                        }
                    }
                } catch (e) {
                    console.log('Could not parse metadata for collection geometry:', e);
                }
                
                const ipcStream = wasmTable.intoIPCStream();
                const arrowTable = arrow.tableFromIPC(ipcStream);
                
                const features = [];
                const geometryColumn = arrowTable.getChild('geometry');
                const idColumn = arrowTable.getChild('id');
                const collectionColumn = arrowTable.getChild('collection');
                const nameColumn = arrowTable.getChild('name');
                const descriptionColumn = arrowTable.getChild('description');
                
                for (let i = 0; i < arrowTable.numRows; i++) {
                const wkbData = geometryColumn?.get(i);
                if (wkbData) {
                    const geom = parseWKB(wkbData);
                    if (geom) {
                        let olGeometry;
                        
                        if (geom.type === 'Point') {
                            const coords = ol.proj.transform(geom.coordinates, 'EPSG:4326', projConfig.code);
                            olGeometry = new ol.geom.Point(coords);
                        } else if (geom.type === 'LineString') {
                            const coords = geom.coordinates.map(c => 
                                ol.proj.transform(c, 'EPSG:4326', projConfig.code)
                            );
                            olGeometry = new ol.geom.LineString(coords);
                        } else if (geom.type === 'Polygon') {
                            const rings = geom.coordinates.map(ring =>
                                ring.map(c => ol.proj.transform(c, 'EPSG:4326', projConfig.code))
                            );
                            olGeometry = new ol.geom.Polygon(rings);
                        }
                        
                        if (olGeometry) {
                            features.push(new ol.Feature({
                                geometry: olGeometry,
                                id: idColumn?.get(i) || `feature_${i}`,
                                collection: collectionColumn?.get(i) || '',
                                name: nameColumn?.get(i) || `Feature ${i}`,
                                description: descriptionColumn?.get(i) || '',
                                source_file: filename
                            }));
                        }
                    }
                }
                }
                
                return features;
            } catch (e) {
                console.error(`Error fetching ${filename}:`, e);
                throw e;
            }
        }
        
        // Initialize and load all parquet files
        async function initialize() {
            try {
                console.log('Initializing parquet-wasm...');
                // Load WASM binary from GCS (local file at: src/xopr/map/parquet_wasm_bg.wasm)
                const wasmPath = 'https://storage.googleapis.com/opr_test_dataset_1/parquet_wasm_bg.wasm';
                
                console.log('Loading WASM binary from GCS');
                await init(wasmPath);
                console.log('parquet-wasm initialized successfully');
                
                // Initialize map with CONFIG
                const mapResult = await initializeMap();
                if (!mapResult) {
                    // No CONFIG provided - error already displayed
                    return;
                }
                const { map, projConfig, CONFIG } = mapResult;
                console.log('Map initialized with CONFIG:', CONFIG);
                
                const allFeatures = [];
                for (const file of CONFIG.parquetFiles) {
                    try {
                        const features = await loadParquetFile(file, projConfig);
                        allFeatures.push(...features);
                    } catch (e) {
                        console.error(`Error loading ${file}:`, e);
                    }
                }
                
                if (allFeatures.length > 0) {
                    const vectorSource = new ol.source.Vector({ features: allFeatures });
                    
                    // Track selected feature
                    let selectedFeature = null;
                    
                    // Style function for different geometry types
                    const styleFunction = function(feature) {
                        const geomType = feature.getGeometry().getType();
                        const isSelected = feature === selectedFeature;
                        
                        // Use blue for selected features, red for normal
                        const color = isSelected ? 'rgba(0, 100, 255, 0.8)' : 'rgba(255, 0, 0, 0.8)';
                        const strokeColor = isSelected ? '#0064ff' : '#ff0000';
                        const fillColor = isSelected ? 'rgba(0, 100, 255, 0.2)' : 'rgba(255, 0, 0, 0.1)';
                        
                        const styles = {
                            'Point': new ol.style.Style({
                                image: new ol.style.Circle({
                                    radius: isSelected ? 8 : 6,
                                    fill: new ol.style.Fill({ color: color }),
                                    stroke: new ol.style.Stroke({ color: '#fff', width: isSelected ? 2 : 1.5 })
                                })
                            }),
                            'LineString': new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: strokeColor,
                                    width: isSelected ? 4 : 2
                                })
                            }),
                            'Polygon': new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: strokeColor,
                                    width: isSelected ? 3 : 2
                                }),
                                fill: new ol.style.Fill({
                                    color: fillColor
                                })
                            })
                        };
                        
                        return styles[geomType] || styles['Point'];
                    };
                    
                    const vectorLayer = new ol.layer.Vector({
                        source: vectorSource,
                        style: styleFunction
                    });
                    
                    map.addLayer(vectorLayer);
                    
                    // Create a layer for collection geometries (green overlay)
                    const collectionSource = new ol.source.Vector();
                    const collectionLayer = new ol.layer.Vector({
                        source: collectionSource,
                        style: new ol.style.Style({
                            stroke: new ol.style.Stroke({
                                color: 'rgba(0, 255, 0, 0.8)',
                                width: 3
                            }),
                            fill: new ol.style.Fill({
                                color: 'rgba(0, 255, 0, 0.1)'
                            }),
                            image: new ol.style.Circle({
                                radius: 10,
                                fill: new ol.style.Fill({ color: 'rgba(0, 255, 0, 0.8)' }),
                                stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                            })
                        })
                    });
                    map.addLayer(collectionLayer);
                    
                    // Fit to extent
                    const extent = vectorSource.getExtent();
                    if (!ol.extent.isEmpty(extent)) {
                        map.getView().fit(extent, {
                            padding: [50, 50, 50, 50],
                            duration: 1000
                        });
                    }
                }
                
                // Feature click handler
                map.on('click', function(evt) {
                    const feature = map.forEachFeatureAtPixel(evt.pixel, f => f);
                    if (feature) {
                        // Update selected feature and refresh styles
                        selectedFeature = feature;
                        vectorSource.changed();  // Trigger style refresh
                        
                        const props = feature.getProperties();
                        
                        // Clear previous collection geometry
                        collectionSource.clear();
                        
                        // Add collection geometry if available
                        const sourceFile = props.source_file;
                        if (sourceFile && collectionGeometries[sourceFile]) {
                            const collGeom = collectionGeometries[sourceFile];
                            let olGeometry;
                            
                            if (collGeom.type === 'LineString') {
                                const coords = collGeom.coordinates.map(c => 
                                    ol.proj.transform(c, 'EPSG:4326', projConfig.code)
                                );
                                olGeometry = new ol.geom.LineString(coords);
                            } else if (collGeom.type === 'Polygon') {
                                const rings = collGeom.coordinates.map(ring =>
                                    ring.map(c => ol.proj.transform(c, 'EPSG:4326', projConfig.code))
                                );
                                olGeometry = new ol.geom.Polygon(rings);
                            } else if (collGeom.type === 'Point') {
                                const coords = ol.proj.transform(collGeom.coordinates, 'EPSG:4326', projConfig.code);
                                olGeometry = new ol.geom.Point(coords);
                            }
                            
                            if (olGeometry) {
                                const collFeature = new ol.Feature({ geometry: olGeometry });
                                collectionSource.addFeature(collFeature);
                            }
                        }
                        
                        document.getElementById('info').innerHTML = 
                            `<strong>ID:</strong> ${props.id}<br><strong>Collection:</strong> ${props.collection}`;
                    } else {
                        // Clear selection when clicking empty space
                        selectedFeature = null;
                        vectorSource.changed();
                        collectionSource.clear();  // Clear collection geometry
                        const coords = evt.coordinate;
                        const lonlat = ol.proj.transform(coords, projConfig.code, 'EPSG:4326');
                        document.getElementById('info').innerHTML = 
                            `${lonlat[1].toFixed(4)}°, ${lonlat[0].toFixed(4)}°`;
                    }
                });
                
                // Hover cursor change
                map.on('pointermove', function(evt) {
                    const pixel = map.getEventPixel(evt.originalEvent);
                    const hit = map.hasFeatureAtPixel(pixel);
                    const targetElement = map.getTargetElement();
                    if (targetElement) {
                        targetElement.style.cursor = hit ? 'pointer' : '';
                    }
                });
                
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('info').innerHTML = 'Error loading data';
            }
        }
        
        // Start with error protection
        initialize().catch(error => {
            console.warn('Map initialization warning:', error.message);
            // Even if there's an error, the map might still work
        });
    </script>
</body>
</html>
